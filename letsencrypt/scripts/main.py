#!/usr/bin/env python
"""Parse command line and call the appropriate functions.

.. todo:: Sanity check all input.  Be sure to avoid shell code etc...

"""
import argparse
import logging
import os
import pkg_resources
import sys

import confargparse
import zope.component

import letsencrypt

from letsencrypt.client import configuration
from letsencrypt.client import client
from letsencrypt.client import errors
from letsencrypt.client import interfaces
from letsencrypt.client import le_util
from letsencrypt.client import log
from letsencrypt.client import standalone_authenticator as standalone
from letsencrypt.client.apache import configurator
from letsencrypt.client.display import util as display_util
from letsencrypt.client.display import ops as display_ops

def apply_on_all(seq, method, *args, **kwargs):
    for obj in seq:
        getattr(obj, method)(*args, **kwargs)

def create_parser():
    """Create parser."""
    parser = confargparse.ConfArgParser(
        description="letsencrypt client %s" % letsencrypt.__version__,
        section = "main")

    config_help = lambda name: interfaces.IConfig[name].__doc__

    subparsers = parser.add_subparsers(metavar='{apache, standalone, revoke}')

    apache_parser = subparsers.add_parser('apache', help='Configure a certificate for Apache')
    apache_parser.set_defaults(authenticator='apache')

    standalone_parser = subparsers.add_parser('standalone', help='Conifgure a standalone certificate')
    standalone_parser.set_defaults(authenticator='standalone')

    revoke_parser = subparsers.add_parser('revoke', help='Revoke a certificate')
    revoke_parser.set_defaults(revoke=True, authenticator='generic')

    generic_parser = subparsers.add_parser('generic')
    generic_parser.set_defaults(authenticator='generic')

    GENERATE_PARSERS = [apache_parser,standalone_parser, generic_parser]
    CONFIGURATION_PARSERS = [apache_parser, generic_parser]

    # Global arguments
    parser.add_argument("-d", "--domains", metavar="DOMAIN", nargs="+")
    parser.add_argument("-s", "--server", default="letsencrypt-demo.org:443",
        help=config_help("server"))
    parser.add_argument("-t", "--text", dest="use_curses", action="store_false",
        help="Use the text output instead of the curses UI.")

    # Certificate generation
    apply_on_all(GENERATE_PARSERS, "add_argument", "-k", "--authkey", type=read_file,
        help="Path to the authorized key file")
    apply_on_all(GENERATE_PARSERS, "add_argument", "-B", "--rsa-key-size", type=int, default=2048, metavar="N",
        help=config_help("rsa_key_size"))
    apply_on_all(GENERATE_PARSERS, "add_argument", "-e", "--agree-tos", dest="eula", action="store_true",
        help="Skip the end user license agreement screen.")
    
    # Revocation
    revoke_parser.add_argument("--revoke-key", dest="rev_key", type=read_file,
        help="Revoke all certs generated by the provided authorized key.")
    revoke_parser.add_argument("--revoke-certificate", dest="rev_cert", type=read_file,
        help="Revoke a specific certificate.")
    revoke_parser.add_argument("--no-confirm", dest="no_confirm", action="store_true",
        help="Turn off confirmation screens")

   
    # Certificate configuration
    apply_on_all(CONFIGURATION_PARSERS, "add_argument", "--apache-server-root", default="/etc/apache2",
        help=config_help("apache_server_root"))
    apply_on_all(CONFIGURATION_PARSERS, "add_argument", "--apache-mod-ssl-conf", default="/etc/letsencrypt/options-ssl.conf",
        help=config_help("apache_mod_ssl_conf"))
    apply_on_all(CONFIGURATION_PARSERS, "add_argument", "--apache-ctl", default="apache2ctl", help=config_help("apache_ctl"))
    apply_on_all(CONFIGURATION_PARSERS, "add_argument", "--apache-enmod", default="a2enmod", help=config_help("apache_enmod"))
    apply_on_all(CONFIGURATION_PARSERS, "add_argument", "--apache-init-script", default="/etc/init.d/apache2",
        help=config_help("apache_init_script"))
    apply_on_all(CONFIGURATION_PARSERS, "add_argument", "--le-vhost-ext", default="-le-ssl.conf",
        help=config_help("le_vhost_ext"))
    apply_on_all(CONFIGURATION_PARSERS, "add_argument", "-b", "--rollback", type=int, default=0, metavar="N",
        help="Revert configuration N number of checkpoints.")
    apply_on_all(CONFIGURATION_PARSERS, "add_argument", "--view-config-changes", action="store_true",
        help="View checkpoints and associated configuration changes.")
    # TODO: resolve - assumes binary logic while client.py assumes ternary.
    apply_on_all(CONFIGURATION_PARSERS, "add_argument", "-r", "--redirect", action="store_true",
        help="Automatically redirect all HTTP traffic to HTTPS for the newly "
             "authenticated vhost.")

    return parser


def main():  # pylint: disable=too-many-branches, too-many-statements
    """Command line argument parsing and main script execution."""
    # note: arg parser internally handles --help (and exits afterwards)
    parser = create_parser()

    # Set a default if no subcommands are passed
    if(len(sys.argv) < 2):
        args = parser.parse_args(['generic'])
    else:
        args = parser.parse_args()

    config = configuration.NamespaceConfig(args)

    # note: check is done after arg parsing as --help should work w/o root also.
    if not os.geteuid() == 0:
        sys.exit(
            "{0}Root is required to run letsencrypt.  Please use sudo.{0}"
            .format(os.linesep))

    # Set up logging
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    if args.use_curses:
        logger.addHandler(log.DialogHandler())
        displayer = display_util.NcursesDisplay()
    else:
        displayer = display_util.FileDisplay(sys.stdout)

    zope.component.provideUtility(displayer)

    try: 
        if args.view_config_changes:
            client.view_config_changes(config)
            sys.exit()
    except AttributeError: 
        pass

    try:
        print  args.revoke
        if args.revoke or args.rev_cert is not None or args.rev_key is not None:
            client.revoke(config, args.no_confirm, args.rev_cert, args.rev_key)
            sys.exit()
    except AttributeError: 
        pass

    try:
        if args.rollback > 0:
            client.rollback(args.rollback, config)
            sys.exit()
    except AttributeError: 
        pass
    try:
        if not args.eula:
            display_eula()
    except AttributeError: 
        pass

    all_auths = {
        'apache': configurator.ApacheConfigurator(config),
        'standalone': standalone.StandaloneAuthenticator(),
    }

    if args.authenticator == 'generic':
        available_auths = list(all_auths.values())
    else: 
        available_auths = [all_auths[args.authenticator]]

    try:
        auth = client.determine_authenticator(available_auths)
    except errors.LetsEncryptClientError:
        logging.critical("No authentication mechanisms were found on your "
                         "system.")
        sys.exit(1)

    if auth is None:
        sys.exit(0)

    # Use the same object if possible
    if interfaces.IInstaller.providedBy(auth):  # pylint: disable=no-member
        installer = auth
    else:
        # This is simple and avoids confusion right now.
        installer = None

    if not hasattr(args, 'domains'):
        args.domains = None
    
    if args.domains is None:
        doms = display_ops.choose_names(installer)
    else:
        doms = args.domains

    if not doms:
        sys.exit(0)

    if not hasattr(args, 'authkey'):
        args.authkey = None

    # Prepare for init of Client
    if args.authkey is None:
        authkey = client.init_key(args.rsa_key_size, config.key_dir)
    else:
        authkey = le_util.Key(args.authkey[0], args.authkey[1])

    acme = client.Client(config, authkey, auth, installer)

    # Validate the key and csr
    client.validate_key_csr(authkey)

    # This more closely mimics the capabilities of the CLI
    # It should be possible for reconfig only, install-only, no-install
    # I am not sure the best way to handle all of the unimplemented abilities,
    # but this code should be safe on all environments.
    cert_file = None
    if auth is not None:
        cert_file, chain_file = acme.obtain_certificate(doms)
    if installer is not None and cert_file is not None:
        acme.deploy_certificate(doms, authkey, cert_file, chain_file)
    if installer is not None:
        acme.enhance_config(doms, args.redirect)


def display_eula():
    """Displays the end user agreement."""
    eula = pkg_resources.resource_string("letsencrypt", "EULA")
    if not zope.component.getUtility(interfaces.IDisplay).yesno(
            eula, "Agree", "Cancel"):
        sys.exit(0)


def read_file(filename):
    """Returns the given file's contents with universal new line support.

    :param str filename: Filename

    :returns: A tuple of filename and its contents
    :rtype: tuple

    :raises argparse.ArgumentTypeError: File does not exist or is not readable.

    """
    try:
        return filename, open(filename, "rU").read()
    except IOError as exc:
        raise argparse.ArgumentTypeError(exc.strerror)


if __name__ == "__main__":
    main()
